<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VEX-notes on Petfactory</title>
    <link>https://www.petfactory.se/tags/vex-notes/</link>
    <description>Recent content in VEX-notes on Petfactory</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 14 Apr 2019 13:45:10 +0100</lastBuildDate>
    
	<atom:link href="https://www.petfactory.se/tags/vex-notes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Houdini - VEX</title>
      <link>https://www.petfactory.se/notes/houdini_vex/</link>
      <pubDate>Sun, 14 Apr 2019 13:45:10 +0100</pubDate>
      
      <guid>https://www.petfactory.se/notes/houdini_vex/</guid>
      <description>Attributes Set attrib type info int pnt = addpoint(0,0);vector4 quat = quaternion(0);setpointattrib(0, &amp;#39;orient&amp;#39;, pnt, quat);setattribtypeinfo(0, &amp;#39;point&amp;#39;, &amp;#39;orient&amp;#39;, &amp;#39;quaternion&amp;#39;);Transform We have control over the distribution of various sizes (bias), the size over life (note that we use the internal @nage i.e. normalized age an attr that comes by default when we do a popsim), min and max scale as well as an overall multiplier.
pscale float ps_life = chramp(&amp;#39;ps_life&amp;#39;, @nage);float ps_bias = fit01(chramp(&amp;#39;ps_bias&amp;#39;, rand(@id)), chf(&amp;#39;ps_min&amp;#39;), chf(&amp;#39;ps_max&amp;#39;));@pscale = ps_life*ps_bias*chf(&amp;#39;ps_mult&amp;#39;);String Regex Replace</description>
    </item>
    
    <item>
      <title>Houdini - VEX Flex</title>
      <link>https://www.petfactory.se/notes/houdini_vex_flex/</link>
      <pubDate>Fri, 12 Apr 2019 13:45:10 +0100</pubDate>
      
      <guid>https://www.petfactory.se/notes/houdini_vex_flex/</guid>
      <description>This is not really VEX flexing but I really liked that title :)
Trigonometry Rotation In an Unreal shader I was building I needed to &amp;ldquo;rotate back&amp;rdquo; some pixels in the normal map so that the normals was corrected when the uv for the texture sampling was rotated. The key is to use the inverted rotation to rotate back the R(U) and G(V) color values (per pixel) so that the map is corrected.</description>
    </item>
    
  </channel>
</rss>